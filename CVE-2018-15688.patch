From: Yu Watanabe <watanabe.yu+github@gmail.com>
Date: Thu, 27 Sep 2018 23:48:51 +0900
Subject: dhcp6: fix buffer size checking

(cherry picked from commit cb1bdeaf56852275e6b0dd1fba932bb174767f70)
(cherry picked from commit 91fb1673d5217aaf1461998fd2675630f5c265f9)
---
 src/systemd/src/libsystemd-network/sd-dhcp6-client.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/systemd/src/libsystemd-network/sd-dhcp6-client.c b/src/systemd/src/libsystemd-network/sd-dhcp6-client.c
index 8444a75..0b261a2 100644
--- a/src/systemd/src/libsystemd-network/sd-dhcp6-client.c
+++ b/src/systemd/src/libsystemd-network/sd-dhcp6-client.c
@@ -818,8 +818,8 @@ static int client_parse_message(
                 uint8_t *optval;
                 be32_t iaid_lease;
 
-                if (len < offsetof(DHCP6Option, data) ||
-                    len < offsetof(DHCP6Option, data) + be16toh(option->len))
+                if (len < pos + offsetof(DHCP6Option, data) ||
+                    len < pos + offsetof(DHCP6Option, data) + be16toh(option->len))
                         return -ENOBUFS;
 
                 optcode = be16toh(option->code);


From: Lennart Poettering <lennart@poettering.net>
Date: Fri, 19 Oct 2018 12:12:33 +0200
Subject: dhcp6: make sure we have enough space for the DHCP6 option header

Fixes a vulnerability originally discovered by Felix Wilhelm from
Google.

CVE-2018-15688
LP: #1795921
https://bugzilla.redhat.com/show_bug.cgi?id=1639067

(cherry picked from commit 4dac5eaba4e419b29c97da38a8b1f82336c2c892)
(cherry picked from commit 01ca2053bbea09f35b958c8cc7631e15469acb79)
(cherry picked from commit fc230dca139142f409d7bac99dbfabe9b004e2fb)
---
 src/systemd/src/libsystemd-network/dhcp6-option.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/systemd/src/libsystemd-network/dhcp6-option.c b/src/systemd/src/libsystemd-network/dhcp6-option.c
index be5c222..2297044 100644
--- a/src/systemd/src/libsystemd-network/dhcp6-option.c
+++ b/src/systemd/src/libsystemd-network/dhcp6-option.c
@@ -105,7 +105,7 @@ int dhcp6_option_append_ia(uint8_t **buf, size_t *buflen, DHCP6IA *ia) {
                 return -EINVAL;
         }
 
-        if (*buflen < len)
+        if (*buflen < offsetof(DHCP6Option, data) + len)
                 return -ENOBUFS;
 
         ia_hdr = *buf;


From: Yu Watanabe <watanabe.yu+github@gmail.com>
Date: Thu, 27 Sep 2018 18:04:59 +0900
Subject: sd-dhcp-lease: fix memleaks

(cherry picked from commit e2975f854831d08a25b4f5eb329b6d04102e115f)
(cherry picked from commit 157094abd83f933fad142758a7d177cfa1a347f7)
---
 src/systemd/src/libsystemd-network/sd-dhcp-lease.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/systemd/src/libsystemd-network/sd-dhcp-lease.c b/src/systemd/src/libsystemd-network/sd-dhcp-lease.c
index d240259..cac07d3 100644
--- a/src/systemd/src/libsystemd-network/sd-dhcp-lease.c
+++ b/src/systemd/src/libsystemd-network/sd-dhcp-lease.c
@@ -279,6 +279,8 @@ sd_dhcp_lease *sd_dhcp_lease_unref(sd_dhcp_lease *lease) {
                 free(option);
         }
 
+        free(lease->root_path);
+        free(lease->timezone);
         free(lease->hostname);
         free(lease->domainname);
         free(lease->dns);


From: Li Song <song.li@honeywell.com>
Date: Fri, 19 Oct 2018 13:41:51 -0400
Subject: sd-dhcp: remove unreachable route after rebinding return NAK

(cherry picked from commit cc3981b1272b9ce37e7d734a7b2f42e84acac535)
(cherry picked from commit 915c2f675a23b2ae16d292d1ac570706f76b384d)
(cherry picked from commit cb77290a696dce924e2a993690634986ac035490)
---
 src/systemd/src/libsystemd-network/sd-dhcp-client.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/systemd/src/libsystemd-network/sd-dhcp-client.c b/src/systemd/src/libsystemd-network/sd-dhcp-client.c
index 42707f1..9158945 100644
--- a/src/systemd/src/libsystemd-network/sd-dhcp-client.c
+++ b/src/systemd/src/libsystemd-network/sd-dhcp-client.c
@@ -1688,6 +1688,8 @@ static int client_handle_message(sd_dhcp_client *client, DHCPMessage *message, i
                         client->timeout_resend =
                                 sd_event_source_unref(client->timeout_resend);
 
+                        client_notify(client, SD_DHCP_CLIENT_EVENT_EXPIRED);
+
                         r = client_initialize(client);
                         if (r < 0)
                                 goto error;

From: Yu Watanabe <watanabe.yu+github@gmail.com>
Date: Fri, 19 Oct 2018 03:44:56 +0900
Subject: sd-dhcp6: fix argument and error handling of
 dhcp6_option_parse_status()

(cherry picked from commit 91c43f3978fa7c8341550b9ca279e460ba7e74e6)
(cherry picked from commit 373cbfc8c6e9591b3c8cc12d58c4b31ac35ab24f)
(cherry picked from commit 0e93fd895daa6f0f578ffa8fc4ed3e0ea85c62e8)
---
 src/systemd/src/libsystemd-network/dhcp6-option.c    | 10 ++++++----
 src/systemd/src/libsystemd-network/sd-dhcp6-client.c |  9 +++++----
 2 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/src/systemd/src/libsystemd-network/dhcp6-option.c b/src/systemd/src/libsystemd-network/dhcp6-option.c
index ff1cbf1..cfddefc 100644
--- a/src/systemd/src/libsystemd-network/dhcp6-option.c
+++ b/src/systemd/src/libsystemd-network/dhcp6-option.c
@@ -465,13 +465,15 @@ int dhcp6_option_parse_ia(DHCP6Option *iaoption, DHCP6IA *ia) {
 
                 case SD_DHCP6_OPTION_STATUS_CODE:
 
-                        status = dhcp6_option_parse_status(option, optlen);
-                        if (status) {
+                        status = dhcp6_option_parse_status(option, optlen + sizeof(DHCP6Option));
+                        if (status < 0) {
+                                r = status;
+                                goto error;
+                        }
+                        if (status > 0) {
                                 log_dhcp6_client(client, "IA status %d",
                                                  status);
 
-                                dhcp6_lease_free_ia(ia);
-
                                 r = -EINVAL;
                                 goto error;
                         }

diff --git a/src/systemd/src/libsystemd-network/sd-dhcp6-client.c b/src/systemd/src/libsystemd-network/sd-dhcp6-client.c
index 0b261a2..b694786 100644
--- a/src/systemd/src/libsystemd-network/sd-dhcp6-client.c
+++ b/src/systemd/src/libsystemd-network/sd-dhcp6-client.c
@@ -870,13 +870,14 @@ static int client_parse_message(
                         break;
 
                 case SD_DHCP6_OPTION_STATUS_CODE:
-                        status = dhcp6_option_parse_status(option, optlen);
-                        if (status) {
+                        status = dhcp6_option_parse_status(option, optlen + sizeof(DHCP6Option));
+                        if (status < 0)
+                                return status;
+
+                        if (status > 0) {
                                 log_dhcp6_client(client, "%s Status %s",
                                                  dhcp6_message_type_to_string(message->type),
                                                  dhcp6_message_status_to_string(status));
-                                dhcp6_lease_free_ia(&lease->ia);
-                                dhcp6_lease_free_ia(&lease->pd);
 
                                 return -EINVAL;
                         }


From: Yu Watanabe <watanabe.yu+github@gmail.com>
Date: Fri, 19 Oct 2018 03:42:10 +0900
Subject: sd-dhcp6: make dhcp6_option_parse_domainname() not store empty
 domain

This improves performance of fuzzer.
C.f. oss-fuzz#11019.

(cherry picked from commit 3c72b6ed4252e7ff5f7704bfe44557ec197b47fa)
(cherry picked from commit 50403cccee28c7dcd54b138a0d3b3f69ea0204fe)
(cherry picked from commit f11f5abb1a8b96b553d2d156f8b5cf440695c04d)
---
 src/systemd/src/libsystemd-network/dhcp6-option.c | 66 ++++++++++-------------
 1 file changed, 29 insertions(+), 37 deletions(-)

diff --git a/src/systemd/src/libsystemd-network/dhcp6-option.c b/src/systemd/src/libsystemd-network/dhcp6-option.c
index cfddefc..be5c222 100644
--- a/src/systemd/src/libsystemd-network/dhcp6-option.c
+++ b/src/systemd/src/libsystemd-network/dhcp6-option.c
@@ -555,6 +555,7 @@ int dhcp6_option_parse_domainname(const uint8_t *optval, uint16_t optlen, char *
                 bool first = true;
 
                 for (;;) {
+                        const char *label;
                         uint8_t c;
 
                         c = optval[pos++];
@@ -562,47 +563,41 @@ int dhcp6_option_parse_domainname(const uint8_t *optval, uint16_t optlen, char *
                         if (c == 0)
                                 /* End of name */
                                 break;
-                        else if (c <= 63) {
-                                const char *label;
-
-                                /* Literal label */
-                                label = (const char *)&optval[pos];
-                                pos += c;
-                                if (pos >= optlen)
-                                        return -EMSGSIZE;
-
-                                if (!GREEDY_REALLOC(ret, allocated, n + !first + DNS_LABEL_ESCAPED_MAX)) {
-                                        r = -ENOMEM;
-                                        goto fail;
-                                }
-
-                                if (first)
-                                        first = false;
-                                else
-                                        ret[n++] = '.';
-
-                                r = dns_label_escape(label, c, ret + n, DNS_LABEL_ESCAPED_MAX);
-                                if (r < 0)
-                                        goto fail;
-
-                                n += r;
-                                continue;
-                        } else {
-                                r = -EBADMSG;
-                                goto fail;
-                        }
-                }
+                        if (c > 63)
+                                return -EBADMSG;
+
+                        /* Literal label */
+                        label = (const char *)&optval[pos];
+                        pos += c;
+                        if (pos >= optlen)
+                                return -EMSGSIZE;
+
+                        if (!GREEDY_REALLOC(ret, allocated, n + !first + DNS_LABEL_ESCAPED_MAX))
+                                return -ENOMEM;
+
+                        if (first)
+                                first = false;
+                        else
+                                ret[n++] = '.';
+
+                        r = dns_label_escape(label, c, ret + n, DNS_LABEL_ESCAPED_MAX);
+                        if (r < 0)
+                                return r;
 
-                if (!GREEDY_REALLOC(ret, allocated, n + 1)) {
-                        r = -ENOMEM;
-                        goto fail;
+                        n += r;
                 }
 
+                if (n == 0)
+                        continue;
+
+                if (!GREEDY_REALLOC(ret, allocated, n + 1))
+                        return -ENOMEM;
+
                 ret[n] = 0;
 
                 r = strv_extend(&names, ret);
                 if (r < 0)
-                        goto fail;
+                        return r;
 
                 idx++;
         }
@@ -610,7 +605,4 @@ int dhcp6_option_parse_domainname(const uint8_t *optval, uint16_t optlen, char *
         *str_arr = TAKE_PTR(names);
 
         return idx;
-
-fail:
-        return r;
 }

From a8cda4b9bd7b70be6bd50ff03345f1428c3c97a1 Mon Sep 17 00:00:00 2001
From: Michael Biebl <biebl@debian.org>
Date: Tue, 30 Oct 2018 09:34:25 +0100
Subject: Force online state with unmanaged devices

Gbp-Pq: Force-online-state-with-unmanaged-devices.patch.

diff --git a/src/nm-manager.c b/src/nm-manager.c
index 7598995..1439c47 100644
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -62,6 +62,8 @@
 #include "nm-dispatcher.h"
 #include "NetworkManagerUtils.h"
 
+#define IFUPDOWN_STATE_FILE "/run/network/ifstate"
+
 /*****************************************************************************/
 
 typedef struct {
@@ -192,6 +194,10 @@ typedef struct {
 	GFileMonitor *fw_monitor;
 	guint fw_changed_id;
 
+	/* ifupdown state file monitor */
+	GFileMonitor *ifstate_monitor;
+	gboolean ifstate_force_online;
+
 	guint timestamp_update_id;
 
 	guint devices_inited_id;
@@ -1417,6 +1423,27 @@ find_best_device_state (NMManager *manager)
 	return best_state;
 }
 
+static NMState
+find_unmanaged_state (NMManager *self, NMState current_state)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMState new_state = current_state;
+	NMDevice *device;
+
+	c_list_for_each_entry (device, &priv->devices_lst_head, devices_lst) {
+		NMDeviceState state = nm_device_get_state (device);
+
+		if (state == NM_DEVICE_STATE_UNMANAGED) {
+			const char *iface = nm_device_get_ip_iface (device);
+			if (priv->ifstate_force_online) {
+				new_state = NM_STATE_CONNECTED_GLOBAL;
+				nm_log_dbg (LOGD_CORE, "Unmanaged device found: %s; state CONNECTED forced.", iface);
+			}
+		}
+	}
+	return new_state;
+}
+
 static void
 nm_manager_update_metered (NMManager *self)
 {
@@ -1455,6 +1482,9 @@ nm_manager_update_state (NMManager *self)
 	else
 		new_state = find_best_device_state (self);
 
+	if (new_state != NM_STATE_CONNECTED_GLOBAL)
+		new_state = find_unmanaged_state (self, new_state);
+
 	if (   new_state >= NM_STATE_CONNECTED_LOCAL
 	    && priv->connectivity_state == NM_CONNECTIVITY_FULL) {
 		new_state = NM_STATE_CONNECTED_GLOBAL;
@@ -6210,6 +6240,62 @@ impl_manager_check_connectivity (NMDBusObject *obj,
 }
 
 static void
+check_ifstate_file (gpointer user_data)
+{
+	NMManager *self = NM_MANAGER (user_data);
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GIOChannel *channel;
+	gchar *line;
+	gboolean online = FALSE;
+
+	channel = g_io_channel_new_file (IFUPDOWN_STATE_FILE, "r", NULL);
+	if (!channel) {
+		nm_log_warn (LOGD_CORE, "Error: failed to open %s", IFUPDOWN_STATE_FILE);
+		return;
+	}
+
+	while (g_io_channel_read_line (channel, &line, NULL, NULL, NULL)
+	       != G_IO_STATUS_EOF && !online) {
+		g_strstrip (line);
+		if (strlen (line) > 0 && g_strcmp0 (line, "lo=lo") != 0) {
+			online = TRUE;
+		}
+		g_free (line);
+	}
+
+	g_io_channel_shutdown (channel, FALSE, NULL);
+	g_io_channel_unref (channel);
+
+	if (priv->ifstate_force_online != online) {
+		priv->ifstate_force_online = online;
+		nm_manager_update_state (self);
+	}
+}
+
+static void
+ifstate_file_changed (GFileMonitor *monitor,
+                      GFile *file,
+                      GFile *other_file,
+                      GFileMonitorEvent event_type,
+                      gpointer user_data)
+{
+	switch (event_type) {
+//	case G_FILE_MONITOR_EVENT_CREATED:
+//#if GLIB_CHECK_VERSION(2,23,4)
+//	case G_FILE_MONITOR_EVENT_MOVED:
+//#endif
+//	case G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED:
+	case G_FILE_MONITOR_EVENT_CHANGED:
+	case G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT:
+		nm_log_dbg (LOGD_CORE, "ifupdown state file %s was changed", IFUPDOWN_STATE_FILE);
+		check_ifstate_file (user_data);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
 start_factory (NMDeviceFactory *factory, gpointer user_data)
 {
 	nm_device_factory_start (factory);
@@ -6377,6 +6463,9 @@ nm_manager_start (NMManager *self, GError **error)
 	nm_clear_g_source (&priv->devices_inited_id);
 	priv->devices_inited_id = g_idle_add_full (G_PRIORITY_LOW + 10, devices_inited_cb, self, NULL);
 
+	/* Trigger ifupdown state file check */
+	check_ifstate_file (self);
+
 	return TRUE;
 }
 
@@ -7231,6 +7320,22 @@ nm_manager_init (NMManager *self)
 		       KERNEL_FIRMWARE_DIR);
 	}
 
+	/* Monitor the ifupdown state file */
+	file = g_file_new_for_path (IFUPDOWN_STATE_FILE);
+	priv->ifstate_monitor = g_file_monitor_file (file, G_FILE_MONITOR_NONE, NULL, NULL);
+	g_object_unref (file);
+
+	if (priv->ifstate_monitor) {
+		g_signal_connect (priv->ifstate_monitor, "changed",
+		                  G_CALLBACK (ifstate_file_changed),
+		                  self);
+		nm_log_info (LOGD_CORE, "monitoring ifupdown state file '%s'.",
+		             IFUPDOWN_STATE_FILE);
+	} else {
+		nm_log_warn (LOGD_CORE, "failed to monitor ifupdown state file '%s'.",
+		             IFUPDOWN_STATE_FILE);
+	}
+
 	/* Update timestamps in active connections */
 	priv->timestamp_update_id = g_timeout_add_seconds (300, (GSourceFunc) periodic_update_active_connection_timestamps, self);
 
@@ -7506,6 +7611,16 @@ dispose (GObject *object)
 		g_clear_object (&priv->fw_monitor);
 	}
 
+	if (priv->ifstate_monitor) {
+		g_signal_handlers_disconnect_by_func (priv->ifstate_monitor, ifstate_file_changed, self);
+
+		if (priv->ifstate_force_online)
+			g_source_remove (priv->ifstate_force_online);
+
+		g_file_monitor_cancel (priv->ifstate_monitor);
+		g_clear_object (&priv->ifstate_monitor);
+	}
+
 	if (priv->rfkill_mgr) {
 		g_signal_handlers_disconnect_by_func (priv->rfkill_mgr, rfkill_manager_rfkill_changed_cb, self);
 		g_clear_object (&priv->rfkill_mgr);
-- 
cgit v0.10.2


From 2d487a9cba9ec09758e869cade0321573509ff7c Mon Sep 17 00:00:00 2001
From: Michael Biebl <biebl@debian.org>
Date: Tue, 30 Oct 2018 09:34:25 +0100
Subject: Don't setup Sleep Monitor if not booted with systemd

Gbp-Pq: Don-t-setup-Sleep-Monitor-if-not-booted-with-systemd.patch.

diff --git a/src/nm-sleep-monitor.c b/src/nm-sleep-monitor.c
index 54d7577..a4bb43f 100644
--- a/src/nm-sleep-monitor.c
+++ b/src/nm-sleep-monitor.c
@@ -25,6 +25,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <gio/gunixfdlist.h>
+#include <systemd/sd-daemon.h>
 
 #include "nm-core-internal.h"
 #include "NetworkManagerUtils.h"
@@ -344,6 +345,10 @@ on_proxy_acquired (GObject *object,
 static void
 nm_sleep_monitor_init (NMSleepMonitor *self)
 {
+	if (!sd_booted()) {
+		nm_log_warn (LOGD_SUSPEND, "Skipping Sleep Monitor setup, system not booted with systemd");
+		return;
+	}
 	self->inhibit_fd = -1;
 	self->cancellable = g_cancellable_new ();
 	g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
-- 
cgit v0.10.2


